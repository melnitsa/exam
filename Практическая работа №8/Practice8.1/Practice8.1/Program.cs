using System.Collections;
using System.Runtime.ConstrainedExecution;
using System;

namespace Practice8._1
{
    internal class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Введите длину массива: ");
            int N = int.Parse(Console.ReadLine());

            int[] array = new int[N];

            for (int i = 0; i < array.Length; i++)
            {
                Console.WriteLine("Введите элемент массива: ");
                array[i] = int.Parse(Console.ReadLine());

            }

            Console.WriteLine("Исходный массив: ");

            for (int i = 0; i < array.Length; i++)
            {
                Console.Write(array[i] + " ");

            }

            Console.WriteLine("\n\nСортировка Вставкой: ");

            int cur;
            int j;
            for (int i = 1; i < array.Length; i++)
            {
                cur = array[i];
                j = i;
                while ((j > 0) && (cur < array[j - 1]))
                {
                    array[j] = array[j - 1];
                    j--;
                }
                array[j] = cur;
            }
            foreach (int value in array)
            {
                Console.Write(value);

            }

            Console.WriteLine("\n\nСортировка Выбором: ");

            int[] array2 = new int[N];
            Array.Copy(array, array2, array.Length); ;

            int indx;
            for (int i = 0; i < array2.Length; i++)
            {
                indx = i;
                for (int l = i; l < array2.Length; l++)
                {
                    if (array2[l] < array2[indx])
                    {
                        indx = l;
                    }
                }
                if (array2[indx] == array2[i])
                {
                    continue;
                }

                int temp = array2[i];
                array2[i] = array2[indx];
                array2[indx] = temp;
            }
            foreach (int value2 in array2)
            {
                Console.Write(value2);
            }

            Console.WriteLine("\n\nСортировка Обменом: ");

            int[] array3 = new int[N];
            Array.Copy(array, array3, array.Length);

            int temp1;

            for (int i = 0; i < array3.Length; i++)
            {
                for (int k = i + 1; k < array3.Length; k++)
                {
                    if (array[i] > array3[k])
                    {
                        temp1 = array3[i];
                        array3[i] = array3[k];
                        array3[k] = temp1;
                    }
                }
            }

            foreach (int value2 in array3)
            {
                Console.Write(value2);
            }

            Console.WriteLine("\n\nМетод двоичного поиска: ");

            Console.WriteLine("Введите критерий поиска: ");
            int b = int.Parse(Console.ReadLine());

            int L = 0;
            int R = N - 1;
            int m = (R + L) / 2;
            int F = 0;

            while (L <= R)
            {
                m = (R + L) / 2;
                if (array[m] == b)
                {
                    Console.WriteLine("Элемент найден на позиции - " + m);
                    F = 1;
                    break;
                }
                else
                {
                    R = m - 1;
                }
            }
            if (F == 0)
            {
                Console.WriteLine("Элемент не найден");
            }
            Console.ReadKey();
        }
    }
}
//1.Сортировка вставкой.
//Принцип метода:
//Массив разделяется на две части: отсортированную и не отсортированную. Элементы из не 
//отсортированной части поочередно выбираются и вставляются в отсортированную часть так,
//чтобы не нарушить в ней упорядоченность элементов. В начале работы алгоритма в качестве 
//отсортированной части массива принимают только один первый элемент, а в качестве не 
//отсортированной части - все остальные элементы.
//Таким образом, алгоритм будет состоять из n-1 прохода (n –размерность массива), каждый из 
//которых будет включать четыре действия:
//-взятие очередного i-го не отсортированного элемента и сохранение его в дополнительной 
//переменной;
//-поиск позиции j в отсортированной части массива, в которой присутствие взятого 
//элемента не нарушит упорядоченности элементов;
//-сдвиг элементов массива от (i-1)-го до j-го впрво, чтобы освободить найденную позицию 
//вставки;
//-вставка взятого элемента в найденную j-ю позицию.
//…
//int cur; // текущий элемент массива
//int j; // текущий индекс
//for (int i = 1; i < array.Length; i++)
//{
//    cur = array[i];
//    j = i;
//    while ((j > 0) && (cur < array[j - 1]))
//    {
//        array[j] = array[j - 1];
//        j--;
//    }
//    array[j] = cur;
//}
//…
 
//2.Сортировка выбором.
//Принцип метода:
//Находим(выбираем) в массиве элемент с минимальным значением на интервале от 1-го до n-го 
//(последнего) элемента и меняем его местами с первым элементом. На втором шаге находим 
//элемент с минимальным значением на интервале от 2-го до n-го элемента и меняем его местами 
//со вторым элементом. И так далее для всех элементов до (n-1)-го.
//…
//int indx; //переменная для хранения индекса минимального элемента массива
//for (int i = 0; i < intArray.Length; i++) //проходим по массиву с начала и до конца
//{
//    indx = i; //считаем, что минимальный элемент имеет текущий индекс
//    for (int j = i; j < intArray.Length; j++) //ищем минимальный элемент
//    {
//        if (intArray[j] < intArray[indx])
//        {
//            indx = j; //нашли в массиве число меньше, чем intArray[indx] 
//        }
//    }
//    if (intArray[indx] == intArray[i]) //если минимальный элемент равен текущему 
//        значению - ничего не меняем
// continue;
//    //меняем местами минимальный элемент и первый в неотсортированной части
//    int temp = intArray[i]; //временная переменная
//    intArray[i] = intArray[indx];
//    intArray[indx] = temp;
//}
//…
//3.Сортировка обменом(“пузырьковая сортировка”)
//Обменные сортировки предусматривают систематический обмен местами между элементами пар 
//значений, в которых нарушена упорядоченность, до тех пор, пока таких элементов не останется. 
//То есть если два элемента расположены неупорядоченно, то они меняются местами. К обменным 
//сортировкам относят:
// метод пузырькового всплытия;
// быструю сортировку(обменную сортировку с разделением);
// обменную сортировку со слиянием;
// поразрядную обменную сортировку.
// Принцип метода пузырьковой сортировки:
//Слева направо поочередно сравниваются два соседних элемента, и если их 
//взаиморасположение не соответствует заданному условию упорядоченности, то они меняются 
//местами. Далее берутся два следующих соседних элемента и так далее до конца массива. 
//После одного такого прохода на последней n-ой позиции массива будет стоять 
//максимальный элемент (“всплыл” первый “пузырек”). Поскольку максимальный элемент уже 
//стоит на своей последней позиции, то второй проход обмена выполняется до (n-1)-го элемента.
//И так далее. Всего требуется (n-1) проход.
// …
//int temp;
//for (int i = 0; i < mas.Length; i++)
//{
//    for (int j = i + 1; j < mas.Length; j++)
//    {
//        if (mas[i] > mas[j])
//        {
//            temp = mas[i];
//            mas[i] = mas[j];
//            mas[j] = temp;
//        }
//    }
//}
//…
//4.Двоичный поиск(бинарный поиск, поиск делением пополам)
//Алгоритм двоичного поиска допустимо использовать для нахождения заданного элемента 
//массива, упорядоченного по неубыванию.
//Принцип двоичного поиска:
//1) Исходный массив делится пополам и для сравнения выбирается средний элемент. Если он 
//совпадает с искомым, то поиск заканчивается. Если же средний элемент меньше искомого,
//то все элементы левее его также будут меньше искомого. Следовательно, их можно 
//исключить из зоны дальнейшего поиска, оставив только правую часть массива. 
//Аналогично, если средний элемент больше искомого, то отбрасывается правая часть, а 
//левая остается.
//2) На втором этапе выполняются аналогичные действия над оставшейся половиной массива. 
//В результате после второго этапа остается ¼ часть массива. 
//3) И так далее, пока или элемент будет найден, или длина зоны поиска станет равной нулю. 
//В последнем случае искомый элемент найден не будет.
//Один из вариантов процедуры, реализующей метод двоичного поиска, будет иметь следующий 
//вид:
//…
//b = Convert.ToInt32.Console.ReadLine(); // критерий поиска
//int L = 0; // левая граница
//int R = n - 1; // правая граница (n – размерность массива)
//int k = (R + L) / 2; //середина
//Int F = 0; //флаг – результат поиска
//While(L <= R)
// {
//    k = (R + L) / 2;
//    if (a[k] == b)
//    {
//        Console.WriteLine(“Элемент найден на позиции - ”+k);
//        F = 1;
//        Break;
//    }
//    else
//    if (a[k] < b)
//        L = k + 1; // поиск в правой половине
//    else
//        R = k - 1; // поиск в левой половине
//}
//if (F == 0)
//{
//    Console.WriteLine(“Элемент не найден”);
//}